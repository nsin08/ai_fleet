name: Enforce Approval Gates

description: |
  Validates approval gates and segregation of duties.
  Reference: 20-rules/05-approval-gates.md

on:
  pull_request_review:
    types: [submitted, dismissed]
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: read
  pull-requests: read

jobs:
  check-approvals:
    runs-on: ubuntu-latest

    steps:
      - name: Validate approval gates
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.setFailed('Missing pull_request payload');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prAuthor = pr.user.login;
            const headSha = pr.head.sha;

            // Reduce reviews to latest state per reviewer
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner,
              repo,
              pull_number: pr.number,
              per_page: 100
            });

            const latestByUser = new Map();
            for (const r of reviews) {
              if (!r.user?.login) continue;
              latestByUser.set(r.user.login, { state: r.state, commitId: r.commit_id });
            }

            const changesRequestedUsers = [];
            const approvalsOnHead = [];

            for (const [user, r] of latestByUser.entries()) {
              if (r.state === 'CHANGES_REQUESTED') changesRequestedUsers.push(user);
              if (r.state === 'APPROVED' && user !== prAuthor && r.commitId === headSha) approvalsOnHead.push(user);
            }

            const selfApproved = latestByUser.get(prAuthor)?.state === 'APPROVED';

            if (selfApproved) {
              core.setFailed('Self-approval is not allowed. PR author cannot approve their own PR.');
              return;
            }

            if (changesRequestedUsers.length > 0) {
              core.setFailed(`Changes requested must be addressed before merge (found: ${changesRequestedUsers.join(', ')})`);
              return;
            }

            if (approvalsOnHead.length < 1) {
              core.setFailed('At least 1 non-author approval on the latest commit is required.');
              return;
            }

            // CODEOWNERS present (warn only; enforced by branch protection setting)
            try {
              await github.rest.repos.getContent({ owner, repo, path: '.github/CODEOWNERS' });
            } catch (e) {
              core.warning('Missing .github/CODEOWNERS (branch protection should require CODEOWNER reviews).');
            }

            console.log(`Approved on latest commit by: ${approvalsOnHead.join(', ')}`);

  check-security-approval:
    runs-on: ubuntu-latest

    steps:
      - name: Check out code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect security-sensitive changes
        id: security
        run: |
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD 2>/dev/null || echo "")
          
          SECURITY_PATTERNS="auth|security|crypto|secret|token|password|key"
          
          if echo "$CHANGED_FILES" | grep -iE "$SECURITY_PATTERNS" > /dev/null 2>&1; then
            echo "security_sensitive=true" >> $GITHUB_OUTPUT
          else
            echo "security_sensitive=false" >> $GITHUB_OUTPUT
          fi

      - name: Require security team approval
        if: steps.security.outputs.security_sensitive == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            core.warning('Security-sensitive files detected; security team approval is recommended (configure via CODEOWNERS/branch protection).');
